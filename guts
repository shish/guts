#!/usr/bin/python

# overall TODO:
# add file-modified-times to the history file, if FMTs
# match, don't bother hashing the whole file

import os
import sys
import argparse
import hashlib
import random
import time


def random_hash():
    base = time.time()
    base = base + random.randint(0, sys.maxint)
    return hashlib.sha1(str(base)).hexdigest()


def read_history(filename):
    lines = file(filename).readlines()

    commits = []
    commit = None
    for line in lines:
        if line.strip() == "":
            continue
        k, v = line.strip().split(":", 1)
        if k == "commit":
            if commit:
                commits.append(commit)
            commit = Commit()
            commit.hash = v
            commit.msg = "waffo"
            commit.changes = []
        if not commit:
            continue
        if k == "author":
            commit.author = v
        if k == "date":
            commit.date = v
        if k == "add":
            commit.changes.append(Add(line.strip()))
        if k == "modify":
            commit.changes.append(Modify(line.strip()))
        if k == "delete":
            commit.changes.append(Delete(line.strip()))
    if commit:
        commits.append(commit)

    return commits


def calc_working_tree():
    files = {}
    for commit in read_history(".gut/history"):
        for ch in commit.changes:
            if ch.type == "add":
                files[ch.filename] = File(ch.filename, ch.mode, ch.object)
            if ch.type == "modify":
                files[ch.filename].old_objects.append(files[ch.filename].object)
                files[ch.filename].mode = ch.mode
                files[ch.filename].object = ch.object
            if ch.type == "delete":
                files[ch.filename] = File(ch.filename, "000000", "0" * 40)
    return files


def scp_down(repo_url, repo_path, local_path):
    repo_url = repo_url.replace("ssh://", "")
    repo_url = repo_url.replace(".org", ".org:")
    os.system('scp -q "%s/%s" "%s"' % (repo_url, repo_path, local_path))


def scp_up(repo_url, local_path, repo_path):
    repo_url = repo_url.replace("ssh://", "")
    repo_url = repo_url.replace(".org", ".org:")
    os.system('scp -q "%s" "%s/%s"' % (local_path, repo_url, repo_path))


#######################################################################
# objects

class Commit(object):
    def __init__(self):
        self.author = "auth <moo>"
        self.date = "moo"
        self.msg = "1234"
        self.hash = "1234"
        self.changes = []

    def to_git(self):
        s = ""
        s = s + "commit %s\n" % self.hash
        s = s + "Author: %s\n" % self.author
        s = s + "Date:   %s\n" % self.date
        s = s + "\n"
        s = s + "    %s\n" % self.msg
        s = s + "\n"
        for change in self.changes:
            s = s + change.to_git() + "\n"
        return s

    def to_gut(self):
        s = ""
        s = s + "revision:%s\n" % self.hash
        s = s + "user:%s\n" % self.author
        s = s + "timestamp:%s\n" % self.date
        for change in self.changes:
            s = s + change.to_gut() + "\n"
        return s

    def to_guts(self):
        s = ""
        s = s + "commit:%s\n" % self.hash
        s = s + "author:%s\n" % self.author
        s = s + "date:%s\n" % self.date
        for change in self.changes:
            s = s + change.to_guts() + "\n"
        return s


class Change(object):
    def __init__(self):
        pass

    def to_guts(self):
        return self.line


class Add(Change):
    def __init__(self, line):
        self.line = line
        self.type, self.filename, self.mode, self.object = line.split(":")

    def to_git(self):
        return ":%s %s %s %s %s  %s" % (
            "000000", self.mode, "0000000...", self.object[0:7] + "...",
            self.type[0].upper(),
            self.filename
        )

    def to_gut(self):
        return "added:" + self.filename


class Modify(Change):
    def __init__(self, line):
        self.line = line
        self.type, self.filename, self.mode, self.object = line.split(":")

    def to_git(self):
        return ":%s %s %s %s %s  %s" % (
            self.mode, self.mode, self.object[0:7] + "...", self.object[0:7] + "...",
            self.type[0].upper(),
            self.filename
        )

    def to_gut(self):
        return "edited:" + self.filename


class Delete(Change):
    def __init__(self, line):
        self.line = line
        self.type, self.filename = line.split(":")

    def to_git(self):
        return ":%s %s %s %s %s  %s" % (
            "100644", "000000", "1234567...", "0000000...",
            self.type[0].upper(),
            self.filename
        )

    def to_gut(self):
        return "deleted:" + self.filename


class File(object):
    def __init__(self, filename, mode, object):
        self.filename = filename
        self.mode = mode
        self.object = object
        self.old_objects = []


#######################################################################
# commands

def identifier():
    print file(".gut/repo_id").read()


def size():
    os.system("du -cb ./ | grep total | cut -f 1")


def history_size():
    os.system("du -cb ./.gut/ | grep total | cut -f 1")


# TODO list local mods (A, M, ? in git status terms)
# is this used?
def unsynced_file_paths():
    pass


def current_revision():
    print hashlib.sha1(file(".gut/history").read()).hexdigest()


def has_remote_changes():
    remote_url = file(".gut/remote_url").read().strip()
    scp_down(remote_url, "history", ".gut/tmp-remote-history")

    local = hashlib.sha1(file(".gut/history").read()).hexdigest()
    remote = hashlib.sha1(file(".gut/tmp-remote-history").read()).hexdigest()

    if local != remote:
        print "true"
        return 0
    else:
        print "false"
        return 1


def has_local_changes():
    files = calc_working_tree()

    # check known files for changes
    for n, wtfilename in enumerate(files):
        f = files[wtfilename]

        if (
            (f.mode == "000000" and os.path.exists(f.filename)) or
            (f.mode != "000000" and not os.path.exists(f.filename)) or
            (f.mode != "000000" and f.object != hashlib.sha1(file(f.filename).read()).hexdigest()) or
            (f.mode != "000000" and os.stat(f.filename)[0] != int(f.mode, 8))
        ):
            print "true"
            return 0

    # check for new files
    actual_files = {}
    for dirpath, dirnames, filenames in os.walk("."):
        if ".gut" in dirpath:
            continue
        for filename in filenames:
            full_name = os.path.join(dirpath, filename)
            if full_name[0:2] == "./":
                full_name = full_name[2:]
            if full_name not in files:
                print "true"
                return 0

    print "false"
    return 1


def sync_up():
    remote_url = file(".gut/remote_url").read().strip()
    author = file(".gut/local_user").read().strip()

    known_files = calc_working_tree()
    actual_files = {}

    for dirpath, dirnames, filenames in os.walk("."):
        if ".gut" in dirpath:
            continue
        for filename in filenames:
            full_name = os.path.join(dirpath, filename)
            if full_name[0:2] == "./":
                full_name = full_name[2:]
            actual_files[full_name] = File(
                full_name,
                "%o" % os.stat(full_name)[0],
                hashlib.sha1(file(full_name).read()).hexdigest()
            )

    commit = Commit()
    commit.hash = random_hash()  # FIXME: hash(previous commit's hash + changes)
    commit.author = author
    commit.date = time.strftime("%Y-%m-%d %H:%M:%S") + " +0000"  # FIXME: timezone
    for f in actual_files:
        if f not in known_files:
            commit.changes.append(Add(":".join([
                "add",
                f,
                actual_files[f].mode,
                actual_files[f].object,
            ])))
    for f in known_files:
        if f not in actual_files:
            if known_files[f].mode != "000000":
                commit.changes.append(Delete("delete:" + f))
    for f in known_files:
        if f in actual_files:
            if actual_files[f].object != known_files[f].object:
                commit.changes.append(Modify(":".join([
                    "modify",
                    f,
                    actual_files[f].mode,
                    actual_files[f].object,
                ])))

    if len(commit.changes) == 0:
        print "no changes to sync"
        return 0

    trim = False

    # TODO: lock repo
    for ch in commit.changes:
        if ch.type == "add" or ch.type == "modify":
            scp_up(remote_url, ch.filename, "objects/%s/%s" % (ch.object[0:2], ch.object))
        if ch.type == "modify" or ch.type == "delete":
            if trim:
                pass  # FIXME: delete file.old_objects[-1]

    h = file(".gut/history", "a")
    h.write("\n")
    h.write(commit.to_guts())
    h.close()

    scp_up(remote_url, ".gut/history", "history")
    # TODO: unlock repo

    if True:
        print "true"
        return 0
    else:
        print "false"
        return 1


def sync_down():
    remote_url = file(".gut/remote_url").read().strip()
    conflicts = False

    print "Downloading history"
    scp_down(remote_url, "history", ".gut/history")

    print "Processing history"
    files = calc_working_tree()

    for n, wtfilename in enumerate(files):
        print >>sys.stderr, "%d%%" % int(n * 100 / len(files))
        print wtfilename
        wtfile = files[wtfilename]

        if wtfile.mode == "000000":
            if os.path.exists(wtfile.filename):
                os.unlink(wtfile.filename)
        else:
            current_hash = None
            if os.path.exists(wtfile.filename):
                current_hash = hashlib.sha1(file(wtfile.filename).read()).hexdigest()

            if wtfile.object != current_hash:
                if current_hash and current_hash not in wtfile.old_objects:
                    conflicts = True
                    os.rename(wtfile.filename, wtfile.filename + "." + str(time.time()))
                filedir = os.path.dirname(wtfile.filename)
                if filedir and not os.path.exists(filedir):
                    os.makedirs(filedir)
                scp_down(remote_url, "objects/%s/%s" % (wtfile.object[0:2], wtfile.object), wtfile.filename)

            if os.stat(wtfile.filename)[0] != int(wtfile.mode, 8):
                os.chmod(wtfile.filename, int(wtfile.mode, 8))

    if not conflicts:
        print "true"
        return 0
    else:
        print "false"
        return 1


def configure(argv):
    target_folder = argv[0]
    remote_url = argv[1][len("--url="):]
    author = argv[2][len("--user="):]

    if not os.path.exists(target_folder+"/.gut"):
        os.makedirs(target_folder)

    file(target_folder + "/.gut/history", "w").write("")
    file(target_folder + "/.gut/remote_url", "w").write(remote_url)
    file(target_folder + "/.gut/local_user", "w").write(author)


def fetch():
    remote_url = file(".gut/remote_url").read().strip()
    scp_down(remote_url, "repo_id", ".gut/repo_id")
    sync_down()


# TODO: limit to last $n
def get_change_sets(argv):
    #count = argv[0]

    for commit in read_history(".gut/history"):
        print commit.to_gut()


def init(argv):
    target = argv[0]
    if not os.path.exists(target):
        os.makedirs(target)
    file(target + "/repo_id", "w").write(random_hash())
    file(target + "/history", "w").write("")
    if not os.path.exists(target + "/objects"):
        os.mkdir(target + "/objects")
        for d in ["%02x" % n for n in range(0, 256)]:
            os.mkdir(target + "/objects/" + d)


def main(argv):
    if len(argv) == 0:
        print "Usage: guts [command]"
        return 1

    if argv[0] == "init": return init(argv[1:])
    if argv[0] == "configure": return configure(argv[1:])
    if argv[0] == "fetch": return fetch()
    if argv[0] == "identifier": return identifier()
    if argv[0] == "size": return size()
    if argv[0] == "history-size": return history_size()
    if argv[0] == "current-revision": return current_revision()
    if argv[0] == "has-remote-changes": return has_remote_changes()
    if argv[0] == "has-local-changes": return has_local_changes()
    if argv[0] == "sync-up": return sync_up()
    if argv[0] == "sync-down": return sync_down()
    if argv[0] == "get-change-sets": return get_change_sets(argv[1:])
    if argv[0] == "unsynced-file-paths": return unsynced_file_paths()


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
